function [dX, ddX] = freefloating_is_captured(dt, xsat, R0s, xtarget, R0t, robot_pre, robot_pre_sim, target, tau, hcapt, init)

% load state vector for satelite and target
r0_sat         = xsat(4:6);
q_sat          = xsat(7:12);
omega0_sat     = xsat(13:15);
r0dot_sat      = xsat(16:18);
qdot_sat       = xsat(19:24);

pos_target   = xtarget(4:6,1);
omega_target = xtarget(7:9,1);
rdot_target  =  xtarget(10:12,1);

% Rotation matrix to transfer satelite's quantities to the inertial fraùe
% with SPART: omega in body frame, rdot in inertial frame
P0_spart = blkdiag(R0s,eye(3));
P0_dot_spart = blkdiag(P0_spart(1:3,1:3)*SkewSym(omega0_sat),zeros(3));

% Rotation matrix to transfer satelite's quantities to the inertial fraùe
% with SPART: omega in body frame, rdot in inertial frame
Pt =  blkdiag(R0t, eye(3));
Pt_dot = blkdiag(R0t*SkewSym(omega_target),zeros(3));

% get matrices from the satelites dynamics (from SPART)
H   = full(robot_pre.dynamics.H(R0s,r0_sat,q_sat));
Hq  = H(7:12,7:12);
H0q = H(1:6,7:12);
H0  = H(1:6,1:6);

C = full(robot_pre.dynamics.C(R0s,r0_sat,q_sat,omega0_sat,r0dot_sat,qdot_sat))*[omega0_sat;r0dot_sat;qdot_sat];
C0 = C(1:6);
Cq = C(7:end);

% get matrices from the target dynamics (from SPART)
Ht      = target.dynamics.H(R0t,pos_target,0);
H_bar   = blkdiag(H,Ht);

% target jacobian
Jt      = target.Jacob(1); 
Jt      = Jt.J0f(R0t,pos_target,0);
Jt_inv  = blkdiag(R0t',eye(3)); % after discussion with Mathieu (Jt computed wrt target's CoM, numerically better)
                                % add SkewSym(rt-rp), bras de levier

% end effector jacobian (from SPART)
EE_idx                  = find(strcmp({robot_pre_sim.links.name},'Link_EE'));

Jee = robot_pre.Jacob(EE_idx);
Je  = Jee.Jmf(R0s,r0_sat,q_sat);
J0  = Jee.J0f(R0s,r0_sat,q_sat);

Ct      = full(full(target.dynamics.C(R0t,pos_target,0,omega_target,rdot_target,0))*[omega_target; rdot_target]);


%% initialize capture
if init
    tt = [P0_spart*H0 P0_spart*H0q; J0 Je]\[zeros(6,1); -Jt*vertcat(omega_target, rdot_target)];
    omega0_sat = tt(1:3);
    r0dot_sat = tt(4:6);
    qdot_sat = tt(7:end);
end

%% Build constrained, reduced dynamics (homogeneous with Overleaf)

Jee_dot = robot_pre.Jacobdot(EE_idx);

Bcim = full([eye(6)     zeros(6);
            zeros(6)    eye(6);
            -Jt_inv*J0 -Jt_inv*Je]);


% get twist of the end effector rL(:,end) already in the inertial frame
% (from SPART)
robot_twist = robot_pre.diffkinematics.tL(R0s,r0_sat,omega0_sat,q_sat,r0dot_sat,qdot_sat);

% compute Je_dot and J0_dot from robot_pre
Je_dot = Jee_dot.Jmdotf(R0s,omega0_sat,r0_sat,q_sat,r0dot_sat,qdot_sat,robot_twist(:,end));
J0_dot = Jee_dot.J0dotf(R0s,omega0_sat,r0_sat,q_sat,r0dot_sat,robot_pre.diffkinematics.t0(R0s,omega0_sat,r0dot_sat));

% calc d(Jt_inv)/dt
Jt_dot = target.Jacobdot(1);
tp = blkdiag(R0t,eye(3))*xtarget(7:end,1);
Jt_inv_dot = full(-Jt_inv*Jt_dot.J0dotf(R0t,omega_target,pos_target,0,rdot_target,tp)*Jt_inv); %check tp


Bcim_dot = full([zeros(12,6) zeros(12,6); -Jt_inv_dot*J0-Jt_inv*J0_dot -Jt_inv_dot*Je-Jt_inv*Je_dot]);
            
H_star  = full(Bcim'*H_bar*Bcim);
C1_star = full(Bcim'*H_bar*Bcim_dot);
C2_star = Bcim'*vertcat(C0,Cq,Ct);

C_star  = full(C1_star*vertcat(omega0_sat,r0dot_sat,qdot_sat) + C2_star); 

% get derivatives for the satelite's inertia matrix (from SPART)
Hdot = robot_pre.Hdot();
H0_dot = Hdot.H0_dotf(R0s,omega0_sat,r0_sat,q_sat,r0dot_sat,qdot_sat);
H0q_dot = Hdot.H0m_dotf(R0s,omega0_sat,r0_sat,q_sat,r0dot_sat,qdot_sat);

% get derivatives for the target's inertia matrix (from SPART)
% Htdot = Ht_dot.H0_dotf(R0t,omega_target,pos_target,0,rdot_target,0);
Htdot = full(target.dynamics.Hdot(R0t,omega_target,pos_target,0,rdot_target,0));

% matrices W_0 and W_{q0} in Overleaf
W0 = P0_spart*H0-Pt*Ht*Jt_inv*J0;
W0_dot = P0_dot_spart*H0 + P0_spart*H0_dot - Pt_dot*Ht*Jt_inv*J0 - Pt*Htdot*Jt_inv*J0 - Pt*Ht*Jt_inv_dot*J0 - Pt*Ht*Jt_inv*J0_dot;

Wq0 = P0_spart*H0q-Pt*Ht*Jt_inv*Je;
Wq0_dot = P0_dot_spart*H0q + P0_spart*H0q_dot - Pt_dot*Ht*Jt_inv*Je - Pt*Htdot*Jt_inv*Je - Pt*Ht*Jt_inv_dot*Je -Pt*Ht*Jt_inv*Je_dot;

%simplify what's to come, inverse only once
W0_inv = inv(W0);
W0i_Wq0 = full(W0_inv*Wq0); 

Qc = [W0_dot Wq0_dot]*vertcat(omega0_sat,r0dot_sat,qdot_sat); 
Bq0 = vertcat(-W0i_Wq0, eye(6));
Bh = vertcat(W0_inv,zeros(6));
Qcbar = vertcat(-W0*Qc,zeros(6,1));

% momentum expressed in the inertial frame
% hcapt = Pt*blkdiag(target_sim.links.inertia*eye(3),target_sim.links.mass*eye(3))*vtg;

% computed final matrices
Hdiamond = Bq0'*H_star*Bq0;
Cdiamond = Bq0'*(C_star+full(Qcbar));

% final dynamics (\ddot{q} in Overleaf)
ddq = Hdiamond\tau - Hdiamond\Cdiamond;

% equation (13) in Overleaf
ddq0_ddq = Bq0*ddq + Qcbar;
ddq0 = ddq0_ddq(1:6);

pinv([W0_dot Wq0_dot])*[W0 Wq0]*vertcat(ddq0,ddq)

% integrate to obtain \dot{q}_0 and \dot{q}, starting from the measured
% quantities
dq0_dq = vertcat(omega0_sat,r0dot_sat,qdot_sat) + dt*vertcat(ddq0,ddq);
q0dot = dq0_dq(1:6);
qdot = dq0_dq(7:end);

% equation (5) in Overleaf
ddq0_ddq_ddqt = Bcim*ddq0_ddq + Bcim_dot*dq0_dq;
ddqt = ddq0_ddq_ddqt(13:18);

%integrate to obtain \dot{q}_t
dqt = xtarget(7:end) + dt*ddqt;

% gather all results and output to function
ddX = ddq0_ddq_ddqt;
dX = vertcat(dq0_dq,dqt);
end