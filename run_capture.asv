addpath(genpath([pwd '\Toolbox_SMS_sym']));
clear all, clc
% close all
import casadi.*

% load robot through URDFs, generate model
robot_path_pre = [pwd '\sms_simple_iftomm.urdf'];
[robot_pre,~] = urdf2robot_flex_visu(robot_path_pre);
[robot_pre_sim]= robot_slx_format(robot_pre);
robot_pre = SPART_casadi(robot_path_pre);

% load target through URDF, generate model
freefloating_path = [pwd '\floating_body.urdf'];
[target,~] = urdf2robot_flex_visu(freefloating_path);
[freefloating_sim]= robot_slx_format(target);
target = SPART_casadi(freefloating_path);

% auxiliary skew symmetric matrix
SkewSym = @(x)[0 -x(3) x(2); x(3) 0 -x(1); -x(2) x(1) 0];

% for quaternion integration and conversions
quaternion = quaternion();

%% System dimensions
clear x_target x_sat theta_t pos_t omega_t rdot_t
xsat = vertcat(zeros(6,1), ...                  % null initial displacements
    zeros(3,1), pi/2*ones(3,1), ...  % first 3: q_wheels, last 3: q_manip
    zeros(12,1));                               % null velocities

% initialize satelite's state vector
theta_sat       = xsat(1:3,1);
pos_sat         = xsat(4:6,1);
q_sat           = xsat(7:12,1);
omega0_sat      = xsat(13:15,1);
r0dot_sat       = xsat(16:18,1);
qrdots          = xsat(19:21,1);
qmdots          = xsat(22:24,1);
R0s = eye(3);
q0s = quaternion.rotm_to_quat(R0s); %initial quaternion, obtained directly from R0


Ht = target.dynamics.H;
Hs = robot_pre.dynamics.H;

link_positions = robot_pre.kinematics.rL(R0s,pos_sat,q_sat);
pos_t = full(link_positions(:,end));

% initialize target's state vector
R0t = eye(3);
q0t = quaternion.rotm_to_quat(R0t);
theta_t(:,1) = quaternion.quat_to_angles(q0t);
rdot_t(:,1)  = [0;0;0];
omega_t(:,1) = [0;0;1e-4];
x_target = vertcat(theta_t, pos_t, omega_t(:,1), rdot_t(:,1));
theta_ff(:,1) = quaternion.quat_to_angles(q0t);
pos_f_CoM(:,1) = full(target.kinematics.rL(R0t,x_target(4:6,1),0)); %just to check

% simulation parameters

N = 500;
is_captured(1:N) = 0;
is_captured(100:end) = 1;
dt = 0.1;

% simulation loop

for k = 1:500
    if ~is_captured(:,k)
        % simulate free target
        pos_ff          = x_target(4:6,k);
        omega0_ff      = x_target(7:9,k);
        r0dot_ff       = x_target(10:12,k);

        feval = target.dynamics.ddX(R0t,pos_ff,omega0_ff,0,r0dot_ff,0,0);
        x_target(:,k+1) = x_target(:,k) + dt*vertcat(x_target(7:end,k),full(feval));


        % update target quaternion, R0 according to next omega
        [q0t, R0t]       = quaternion.integrate(x_target(7:9,k+1),q0t,dt);
        theta_ff(:,k+1)  = quaternion.quat_to_angles(q0t);
        pos_f_CoM(:,k+1) = full(target.kinematics.rL(R0t,x_target(4:6,k+1),0)); %just to check

        pos_t(:,k+1)   = x_target(1:3,k+1);
        omega_t(:,k+1) = x_target(4:6,k+1);
        rdot_t(:,k+1)  = x_target(7:9,k+1);
    
        % simulate free robot
        pos_sat        = xsat(4:6,k);
        q_sat          = xsat(7:12,k);
        omega0_sat     = xsat(13:15,k);
        r0dot_sat      = xsat(16:18,k);
        qdot_sat       = xsat(19:24,k);

        torque_r(:,k) = zeros(3,1);
        torque_m(:,k) = zeros(3,1);
        feval = robot_pre.dynamics.ddX(R0s,pos_sat,omega0_sat,q_sat,r0dot_sat,qdot_sat,vertcat(torque_r(:,k),torque_m(:,k)));
        xsat(:,k+1) = xsat(:,k) + dt*vertcat(xsat(13:end,k),full(feval));

        % update satelite quaternion, R0 according to next omega
        [q0s, R0s]  = quaternion.integrate(xsat(13:15,k+1),q0s,dt);
        theta_sat(:,k)      = quaternion.quat_to_angles(q0s);

        Hs_v = full(robot_pre.dynamics.H(R0s,pos_sat,q_sat));
        Ht_v = full(target.dynamics.H(R0t,x_target(4:6,k),0));
        P0 = blkdiag(R0s,eye(3));
        Pt = blkdiag(R0t,eye(3));
        [P0*Hs_v(1:6,1:6)*xsat(13:18,k)+P0*Hs_v(1:6,7:end)*xsat(19:end,k) Pt*Ht_v*x_target(7:end,k)]

%         link_positions = robot_pre.kinematics.rL(R0s,pos_sat,q_sat);
%         pos_ee = full(link_positions(:,end));
%         [pos_ee x_target(4:6,end)]
% 
%         link_vel = robot_pre.diffkinematics.tL(R0s,pos_sat,omega0_sat,q_sat,r0dot_sat,qdot_sat);
%         target_vel = target.diffkinematics.tL(R0t,x_target(4:6,k),x_target(7:9,k),0,x_target(10:12,k),0);
%         [link_vel(:,end) target_vel]

    else
        if k == 100
            Ht_v = full(target.dynamics.H(R0t,x_target(4:6,100),0));
            Pt = blkdiag(R0t,eye(3));
            hcapt = Pt*Ht_v*x_target(7:end,100);
            init = 1;
        else
            init = 0;
        end

        % Recall: dX_captured is vertcat(q0dot,qdot,qtdot)
        [dX_captured] = freefloating_is_captured(dt, xsat(:,k), R0s, x_target(:,k), R0t, robot_pre, robot_pre_sim, target, zeros(6,1), hcapt, init);
        
        % update satelite's velocities, quaternion, and then integrate
        xsat(13:end,k+1) = full(dX_captured(1:12));
        
        pos_sat        = xsat(4:6,k);
        q_sat          = xsat(7:12,k);
        omega0_sat     = xsat(13:15,k);
        r0dot_sat      = xsat(16:18,k);
        qdot_sat       = xsat(19:24,k);
        
        %update quaternion and R0
        [q0s, R0s]  = quaternion.integrate(xsat(13:end,k+1),q0s,dt);

        % update satelite's positions
        xsat(1:12,k+1) = xsat(1:12,k) + dt*xsat(13:end,k);
        theta_sat(:,k) = quaternion.quat_to_angles(q0s);

        % update target velocities, quaternion
        x_target(7:end,k+1) = full(dX_captured(13:end));
        [q0t, R0t]          = quaternion.integrate(x_target(7:end,k+1),q0t,dt);
        theta_ff(:,k+1)     = quaternion.quat_to_angles(q0t);

        % integrate 
        x_target(1:6,k+1) = x_target(1:6,k) + dt*x_target(7:end,k);
        theta_t(:,k)    = quaternion.quat_to_angles(q0t);

        % this is only for debugging, trying to see if shit works
        link_vel = robot_pre.diffkinematics.tL(R0s,pos_sat,omega0_sat,q_sat,r0dot_sat,qdot_sat);
        target_vel = target.diffkinematics.tL(R0t,x_target(4:6,k),x_target(7:9,k),0,x_target(10:12,k),0);
        sprintf('Norm of the difference end_effector_vel - target_vel: %f', full(norm([link_vel(:,end)+target_vel])))
        
        Hs_v = full(robot_pre.dynamics.H(R0s,pos_sat,q_sat));
        Ht_v = full(target.dynamics.H(R0t,x_target(4:6,k),0));
        P0 = blkdiag(R0s,eye(3));
        Pt = blkdiag(R0t,eye(3));
        sprintf('[Moment servicer+target, moment of target at capture (cte)]:')
        [P0*Hs_v(1:6,1:6)*xsat(13:18,k)+P0*Hs_v(1:6,7:end)*xsat(19:end,k)+Pt*Ht_v*x_target(7:end,k) hcapt]
    end
end


figure(1)
plot(xsat(1,:),'r')
hold on
plot(xsat(2,:),'g')
plot(xsat(3,:),'b')
title('Base orientation')


figure(2)
plot(xsat(4,:),'r')
hold on
plot(xsat(5,:),'g')
plot(xsat(6,:),'b')
title('Base position (r0)')

figure(3)
plot(xsat(7,:),'--r')
hold on
plot(xsat(8,:),'--g')
plot(xsat(9,:),'--b')
plot(xsat(10,:),'r')
plot(xsat(11,:),'g')
plot(xsat(12,:),'b')
title('Servicer joints (reaction wheels (--), arm joints (-))')

figure(4)
plot(xsat(13,:),'r')
hold on
plot(xsat(14,:),'g')
plot(xsat(15,:),'b')
title('Base angular velocity')


figure(5)
plot(xsat(16,:),'r')
hold on
plot(xsat(17,:),'g')
plot(xsat(18,:),'b')
title('Base linear velocity (r0)')

figure(2)
plot(xsat(7,:),'--r')
hold on
plot(xsat(8,:),'--g')
plot(xsat(9,:),'--b')
plot(xsat(10,:),'r')
plot(xsat(11,:),'g')
plot(xsat(12,:),'b')
title('Servicer joints (reaction wheels (--), arm joints (-))')