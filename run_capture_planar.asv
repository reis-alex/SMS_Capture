addpath(genpath([pwd '\Toolbox_SMS_sym']));
clear all, clc
% close all
import casadi.*

% load robot through URDFs, generate model
robot_path_pre = [pwd '\planar_robot.urdf'];
[satelite,~] = urdf2robot_flex_visu(robot_path_pre);
[robot_pre_sim]= robot_slx_format(satelite);
satelite = SPART_casadi(robot_path_pre);

% load target through URDF, generate model
freefloating_path = [pwd '\floating_body.urdf'];
[target,~] = urdf2robot_flex_visu(freefloating_path);
[freefloating_sim]= robot_slx_format(target);
target = SPART_casadi(freefloating_path);

% auxiliary skew symmetric matrix
SkewSym = @(x)[0 -x(3) x(2); x(3) 0 -x(1); -x(2) x(1) 0];

% for quaternion integration and conversions
quaternion = quaternion();



%% System dimensions
clear x_target x_sat theta_t pos_t omega_t rdot_t
xsat = vertcat(zeros(6,1), ...                  % null initial displacements
                0,0,0, ...                      % first 3: q_wheels, last 3: q_manip
                zeros(9,1));                    % null velocities

%     zeros(3,1), pi/2,-0.1569,0, ...  % first 3: q_wheels, last 3: q_manip

R0s = eye(3);
q0s = quaternion.rotm_to_quat(R0s); %initial quaternion, obtained directly from R0


Ht = target.dynamics.H;
Hs = satelite.dynamics.H;

link_positions = satelite.kinematics.rL(R0s,xsat);
pos_t = full(link_positions(:,end))
%%

% initialize target's state vector
R0t(:,:,1) = eye(3);
q0t(:,1) = quaternion.rotm_to_quat(R0t(:,:,1));
theta_t(:,1) = quaternion.quat_to_angles(q0t(:,1));
rdot_t(:,1)  = [0;0;0];
omega_t(:,1) = [0;0.1;0];
x_target = vertcat(theta_t, pos_t, omega_t(:,1), rdot_t(:,1));
theta_ff(:,1) = quaternion.quat_to_angles(q0t(:,1));
pos_f_CoM(:,1) = full(target.kinematics.rL(R0t(:,:,1),x_target)); %just to check

% simulation parameters

dt = 0.0001;
total_moment = [];
kcapt = 10;
% simulation loop

for k = 1:20000
    k
    if k<kcapt
        % simulate free target
        feval = target.dynamics.ddX(R0t(:,:,k),x_target(:,k),0);
        x_target(:,k+1) = x_target(:,k) + dt*vertcat(x_target(target.idx.velocities,k),full(feval));


        % update target quaternion, R0 according to next omega
        [q0t(:,k+1), R0t(:,:,k+1)]       = quaternion.integrate(x_target(target.idx.omega0,k),q0t(:,k),dt);
    
        % simulate free robot
        torque_m(:,k) = zeros(3,1);
        feval = satelite.dynamics.ddX(R0s(:,:,k),xsat(:,k),torque_m(:,k));
        xsat(:,k+1) = xsat(:,k) + dt*vertcat(xsat(satelite.idx.velocities,k),full(feval));

        % update satelite quaternion, R0 according to next omega
        [q0s(:,k+1), R0s(:,:,k+1)]  = quaternion.integrate(xsat(satelite.idx.omega0,k),q0s(:,k),dt);
        theta_sat(:,k)      = quaternion.quat_to_angles(q0s);

        total_moment = horzcat(total_moment, compute_moment(satelite, target,R0s(:,:,k),R0t(:,:,k),xsat(:,k),x_target(:,k)));


    else
        if k == kcapt
            Ht_v = full(target.dynamics.H(R0t,x_target(:,kcapt)));
            Hs_v = satelite.dynamics.H(R0s,xsat);
            P0 = blkdiag(R0s(:,:,kcapt),eye(3));
            Pt = blkdiag(R0t(:,:,kcapt),eye(3));
            hcapt = compute_moment(satelite, target, zeros(3),R0t(:,:,k),xsat(:,k),x_target(:,k))
            EE_idx = find(strcmp({satelite.robot.links.name},'Link_EE'));
            Jee = satelite.Jacob(EE_idx);
            Je  = full(Jee.Jmf(R0s(:,:,kcapt),xsat(:,kcapt)));
            J0  = full(Jee.J0f(R0s(:,:,kcapt),xsat(:,kcapt)));
            Jt = blkdiag(R0t(:,:,kcapt),eye(3));
            xsat(satelite.idx.velocities,kcapt)  = full(pinv([P0*Hs_v(1:6,1:6) P0*Hs_v(1:6,7:end); J0 Je])*[zeros(6,1); -Jt*vertcat(x_target(7:9,kcapt), x_target(10:12,kcapt))]);

        end


        % Recall: dX_captured is vertcat(q0dot,qdot,qtdot)
        [xsat_plus, xtarget_plus] = freefloating_is_captured_planar(dt, xsat(:,k), R0s(:,:,k), x_target(:,k), R0t(:,:,k), satelite, robot_pre_sim, target, zeros(3,1), hcapt);
        xsat(:,k+1) = xsat_plus;
        x_target(:,k+1) = xtarget_plus;
        
        %update quaternion and R0
        [q0s(:,k+1), R0s(:,:,k+1)]  = quaternion.integrate(xsat(10:end,k+1),q0s(:,k),dt);
        [q0t(:,k+1), R0t(:,:,k+1)]  = quaternion.integrate(x_target(7:end,k+1),q0t(:,k),dt);

        % compute total moment at k
        Hsv = satelite.dynamics.H(R0s(:,:,k),xsat(4:6,k),xsat(7:9,k));
        Htv = target.dynamics.H(R0t(:,:,k),x_target(4:6,k),0);
        total_moment = horzcat(total_moment, compute_moment(R0s(:,:,k),R0t(:,:,k),xsat(:,k),x_target(:,k)));

    end
end

for k = 1:length(xsat)
    v0 = xsat(10:15,k);
    vq = xsat(16:end,k);
    vt = x_target(7:12,k);
    resid(k) = norm(J0*v0 + Je*vq + Jt*vt);
end
plot((1:length(xsat)), resid(1:end));
xlabel('time index'); ylabel('constraint residual');


%% 
figure(1)
plot(xsat(1,:),'r')
hold on
plot(xsat(2,:),'g')
plot(xsat(3,:),'b')
title('Base orientation')


figure(2)
plot(xsat(4,:),'r')
hold on
plot(xsat(5,:),'g')
plot(xsat(6,:),'b')
title('Base position (r0)')

figure(3)
plot(xsat(7,:),'--r')
hold on
plot(xsat(8,:),'--g')
plot(xsat(9,:),'--b')
title('Servicer joint')

figure(4)
plot(xsat(10,:),'r')
hold on
plot(xsat(11,:),'g')
plot(xsat(12,:),'b')
title('Base angular velocity')


figure(5)
plot(xsat(13,:),'r')
hold on
plot(xsat(14,:),'g')
plot(xsat(15,:),'b')
title('Base linear velocity (\dot(r)_0)')

figure(6)
plot(xsat(16,:),'-r')
hold on
plot(xsat(17,:),'-g')
plot(xsat(18,:),'-b')
title('Servicer joint velocities (reaction wheels (--), arm joints (-))')

figure(7)
plot(x_target(1,:),'r')
hold on
plot(x_target(2,:),'g')
plot(x_target(3,:),'b')
title('Target orientation')

figure(8)
plot(x_target(4,:),'r')
hold on
plot(x_target(5,:),'g')
plot(x_target(6,:),'b')
title('Target position')

figure(9)
plot(x_target(7,:),'r')
hold on
plot(x_target(8,:),'g')
plot(x_target(9,:),'b')
title('Target angular velocity')

figure(10)
plot(x_target(10,:),'r')
hold on
plot(x_target(11,:),'g')
plot(x_target(12,:),'b')
title('Target linear velocity')

%% Auxiliary functions


function m = compute_moment(satelite, target, R0s,R0t,xsat,x_target)
    Ht_v = full(target.dynamics.H(R0t,x_target));
    Hs_v = satelite.dynamics.H(R0s,xsat);
    m = full(blkdiag(R0s,eye(3))*(Hs_v(1:6,1:6)*xsat(10:15) + Hs_v(1:6,7:end)*xsat(16:end)) + blkdiag(R0t,eye(3))*Ht_v*x_target(7:end));
end
